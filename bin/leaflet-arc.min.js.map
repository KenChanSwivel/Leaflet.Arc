{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///leaflet-arc.min.js","webpack:///webpack/bootstrap 3a75f1df5d02d3b90aa8","webpack:///./~/arc/index.js","webpack:///./~/arc/arc.js","webpack:///./src/leaflet-arc.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","D2R","Math","PI","R2D","Coord","lon","lat","x","y","view","String","slice","antipode","anti_lat","anti_lon","LineString","coords","length","move_to","coord","push","Arc","properties","geometries","json","geometry","type","coordinates","multiline","wkt","wkt_string","collect","forEach","substring","GreatCircle","start","end","undefined","Error","w","h","z","pow","sin","cos","g","asin","sqrt","isNaN","interpolate","f","A","B","atan2","npoints","options","first_pass","delta","step","pair","bHasBigDiff","dfMaxSmallDiffLong","dfDateLineOffset","offset","dfLeftBorderX","dfRightBorderX","dfDiffSpace","j","dfPrevX","dfX","dfDiffLong","abs","poMulti","poNewLS","k","dfX0","parseFloat","dfX1","dfY1","dfX2","dfY2","tmpX","tmpY","dfRatio","dfY","poNewLS0","arc","line","points","j0","window","_createLatLngs","from","_ret","wrap","lng","v","map","subLine","point","L","latLng","reduce","all","latlngs","concat","_typeof","_extends","assign","target","arguments","source","key","Symbol","iterator","obj","constructor","_latLngToXY","latlng","Polyline","_from","_to","_options","to","vertices","generator","arcLine","latLngs","polyline"],"mappings":"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","file":"leaflet-arc.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"leaflet-arc\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"leaflet-arc\"] = factory();\n\telse\n\t\troot[\"leaflet-arc\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"leaflet-arc\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"leaflet-arc\"] = factory();\n\telse\n\t\troot[\"leaflet-arc\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function Coord(lon, lat) {\n    this.lon = lon;\n    this.lat = lat;\n    this.x = D2R * lon;\n    this.y = D2R * lat;\n};\n\nCoord.prototype.view = function () {\n    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function () {\n    var anti_lat = -1 * this.lat;\n    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n    return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function LineString() {\n    this.coords = [];\n    this.length = 0;\n};\n\nLineString.prototype.move_to = function (coord) {\n    this.length++;\n    this.coords.push(coord);\n};\n\nvar Arc = function Arc(properties) {\n    this.properties = properties || {};\n    this.geometries = [];\n};\n\nArc.prototype.json = function () {\n    if (this.geometries.length <= 0) {\n        return { 'geometry': { 'type': 'LineString', 'coordinates': null },\n            'type': 'Feature', 'properties': this.properties\n        };\n    } else if (this.geometries.length == 1) {\n        return { 'geometry': { 'type': 'LineString', 'coordinates': this.geometries[0].coords },\n            'type': 'Feature', 'properties': this.properties\n        };\n    } else {\n        var multiline = [];\n        for (var i = 0; i < this.geometries.length; i++) {\n            multiline.push(this.geometries[i].coords);\n        }\n        return { 'geometry': { 'type': 'MultiLineString', 'coordinates': multiline },\n            'type': 'Feature', 'properties': this.properties\n        };\n    }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function () {\n    var wkt_string = '';\n    var wkt = 'LINESTRING(';\n    var collect = function collect(c) {\n        wkt += c[0] + ' ' + c[1] + ',';\n    };\n    for (var i = 0; i < this.geometries.length; i++) {\n        if (this.geometries[i].coords.length === 0) {\n            return 'LINESTRING(empty)';\n        } else {\n            var coords = this.geometries[i].coords;\n            coords.forEach(collect);\n            wkt_string += wkt.substring(0, wkt.length - 1) + ')';\n        }\n    }\n    return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function GreatCircle(start, end, properties) {\n    if (!start || start.x === undefined || start.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    if (!end || end.x === undefined || end.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    this.start = new Coord(start.x, start.y);\n    this.end = new Coord(end.x, end.y);\n    this.properties = properties || {};\n\n    var w = this.start.x - this.end.x;\n    var h = this.start.y - this.end.y;\n    var z = Math.pow(Math.sin(h / 2.0), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2.0), 2);\n    this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n    if (this.g == Math.PI) {\n        throw new Error('it appears ' + start.view() + ' and ' + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n    } else if (isNaN(this.g)) {\n        throw new Error('could not calculate great circle between ' + start + ' and ' + end);\n    }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function (f) {\n    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n    var B = Math.sin(f * this.g) / Math.sin(this.g);\n    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n    var lon = R2D * Math.atan2(y, x);\n    return [lon, lat];\n};\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function (npoints, options) {\n    var first_pass = [];\n    if (!npoints || npoints <= 2) {\n        first_pass.push([this.start.lon, this.start.lat]);\n        first_pass.push([this.end.lon, this.end.lat]);\n    } else {\n        var delta = 1.0 / (npoints - 1);\n        for (var i = 0; i < npoints; ++i) {\n            var step = delta * i;\n            var pair = this.interpolate(step);\n            first_pass.push(pair);\n        }\n    }\n    /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n       TODO - does not handle all wrapping scenarios yet\n    */\n    var bHasBigDiff = false;\n    var dfMaxSmallDiffLong = 0;\n    // from http://www.gdal.org/ogr2ogr.html\n    // -datelineoffset:\n    // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n    var dfDateLineOffset = options && options.offset ? options.offset : 10;\n    var dfLeftBorderX = 180 - dfDateLineOffset;\n    var dfRightBorderX = -180 + dfDateLineOffset;\n    var dfDiffSpace = 360 - dfDateLineOffset;\n\n    // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n    for (var j = 1; j < first_pass.length; ++j) {\n        var dfPrevX = first_pass[j - 1][0];\n        var dfX = first_pass[j][0];\n        var dfDiffLong = Math.abs(dfX - dfPrevX);\n        if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {\n            bHasBigDiff = true;\n        } else if (dfDiffLong > dfMaxSmallDiffLong) {\n            dfMaxSmallDiffLong = dfDiffLong;\n        }\n    }\n\n    var poMulti = [];\n    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n        var poNewLS = [];\n        poMulti.push(poNewLS);\n        for (var k = 0; k < first_pass.length; ++k) {\n            var dfX0 = parseFloat(first_pass[k][0]);\n            if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n                var dfX1 = parseFloat(first_pass[k - 1][0]);\n                var dfY1 = parseFloat(first_pass[k - 1][1]);\n                var dfX2 = parseFloat(first_pass[k][0]);\n                var dfY2 = parseFloat(first_pass[k][1]);\n                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 == 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {\n                    poNewLS.push([-180, first_pass[k][1]]);\n                    k++;\n                    poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                    continue;\n                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 == -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {\n                    poNewLS.push([180, first_pass[k][1]]);\n                    k++;\n                    poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                    continue;\n                }\n\n                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n                    // swap dfX1, dfX2\n                    var tmpX = dfX1;\n                    dfX1 = dfX2;\n                    dfX2 = tmpX;\n                    // swap dfY1, dfY2\n                    var tmpY = dfY1;\n                    dfY1 = dfY2;\n                    dfY2 = tmpY;\n                }\n                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n                    dfX2 += 360;\n                }\n\n                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n                    poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n                    poNewLS = [];\n                    poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n                    poMulti.push(poNewLS);\n                } else {\n                    poNewLS = [];\n                    poMulti.push(poNewLS);\n                }\n                poNewLS.push([dfX0, first_pass[k][1]]);\n            } else {\n                poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n            }\n        }\n    } else {\n        // add normally\n        var poNewLS0 = [];\n        poMulti.push(poNewLS0);\n        for (var l = 0; l < first_pass.length; ++l) {\n            poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n        }\n    }\n\n    var arc = new Arc(this.properties);\n    for (var m = 0; m < poMulti.length; ++m) {\n        var line = new LineString();\n        arc.geometries.push(line);\n        var points = poMulti[m];\n        for (var j0 = 0; j0 < points.length; ++j0) {\n            line.move_to(points[j0]);\n        }\n    }\n    return arc;\n};\n\nif (typeof window === 'undefined') {\n    // nodejs\n    module.exports.Coord = Coord;\n    module.exports.Arc = Arc;\n    module.exports.GreatCircle = GreatCircle;\n} else {\n    // browser\n    var arc = {};\n    arc.Coord = Coord;\n    arc.Arc = Arc;\n    arc.GreatCircle = GreatCircle;\n}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n__webpack_require__(0);\n\n/**\n * Transform L.LatLng to {x, y} object\n * @param {L.LatLng} latlng\n * @returns {{x: {number}, y: {number}}}\n * @private\n */\nvar _latLngToXY = function _latLngToXY(latlng) {\n    return {\n        x: latlng.lng,\n        y: latlng.lat\n    };\n};\n\n/**\n * Create array of L.LatLng objects from line produced by arc.js\n * @param {object} line\n * @param {L.LatLng} from\n * @private\n * @returns {Array}\n */\nfunction _createLatLngs(line, from) {\n    if (line.geometries[0] && line.geometries[0].coords[0]) {\n        var _ret = function () {\n            /**\n             * stores how many times arc is broken over 180 longitude\n             * @type {number}\n             */\n            var wrap = from.lng - line.geometries[0].coords[0][0] - 360;\n\n            return {\n                v: line.geometries.map(function (subLine) {\n                    wrap += 360;\n                    return subLine.coords.map(function (point) {\n                        return L.latLng([point[1], point[0] + wrap]);\n                    });\n                }).reduce(function (all, latlngs) {\n                    return all.concat(latlngs);\n                })\n            };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    } else {\n        return [];\n    }\n}\n\nif (!L) {\n    throw new Error('Leaflet is not defined');\n} else {\n    /**\n     *\n     * @param {L.LatLng} _from\n     * @param {L.LatLng} _to\n     * @param {...object} _options\n     * @param {..number} _options.vertices\n     * @param {..number} _options.offset\n     * @returns {L.Polyline}\n     * @constructor\n     */\n    L.Polyline.Arc = function (_from, _to, _options) {\n\n        var from = L.latLng(_from);\n        var to = L.latLng(_to);\n        var options = _extends({\n            vertices: 10,\n            offset: 10\n        }, _options);\n\n        var generator = new arc.GreatCircle(_latLngToXY(from), _latLngToXY(to));\n\n        var arcLine = generator.Arc(options.vertices, { offset: options.offset });\n        var latLngs = _createLatLngs(arcLine, from);\n        return L.polyline(latLngs, options);\n    };\n}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// leaflet-arc.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3a75f1df5d02d3b90aa8","module.exports = require('./arc');\n\n\n\n// WEBPACK FOOTER //\n// ./~/arc/index.js","'use strict';\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function(lon,lat) {\n    this.lon = lon;\n    this.lat = lat;\n    this.x = D2R * lon;\n    this.y = D2R * lat;\n};\n\nCoord.prototype.view = function() {\n    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function() {\n    var anti_lat = -1 * this.lat;\n    var anti_lon = (this.lon < 0) ? 180 + this.lon : (180 - this.lon) * -1;\n    return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function() {\n    this.coords = [];\n    this.length = 0;\n};\n\nLineString.prototype.move_to = function(coord) {\n    this.length++;\n    this.coords.push(coord);\n};\n\nvar Arc = function(properties) {\n    this.properties = properties || {};\n    this.geometries = [];\n};\n\nArc.prototype.json = function() {\n    if (this.geometries.length <= 0) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': null },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else if (this.geometries.length == 1) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': this.geometries[0].coords },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else {\n        var multiline = [];\n        for (var i = 0; i < this.geometries.length; i++) {\n            multiline.push(this.geometries[i].coords);\n        }\n        return {'geometry': { 'type': 'MultiLineString', 'coordinates': multiline },\n                'type': 'Feature', 'properties': this.properties\n               };\n    }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function() {\n    var wkt_string = '';\n    var wkt = 'LINESTRING(';\n    var collect = function(c) { wkt += c[0] + ' ' + c[1] + ','; };\n    for (var i = 0; i < this.geometries.length; i++) {\n        if (this.geometries[i].coords.length === 0) {\n            return 'LINESTRING(empty)';\n        } else {\n            var coords = this.geometries[i].coords;\n            coords.forEach(collect);\n            wkt_string += wkt.substring(0, wkt.length - 1) + ')';\n        }\n    }\n    return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function(start,end,properties) {\n    if (!start || start.x === undefined || start.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    if (!end || end.x === undefined || end.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    this.start = new Coord(start.x,start.y);\n    this.end = new Coord(end.x,end.y);\n    this.properties = properties || {};\n\n    var w = this.start.x - this.end.x;\n    var h = this.start.y - this.end.y;\n    var z = Math.pow(Math.sin(h / 2.0), 2) +\n                Math.cos(this.start.y) *\n                   Math.cos(this.end.y) *\n                     Math.pow(Math.sin(w / 2.0), 2);\n    this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n    if (this.g == Math.PI) {\n        throw new Error('it appears ' + start.view() + ' and ' + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n    } else if (isNaN(this.g)) {\n        throw new Error('could not calculate great circle between ' + start + ' and ' + end);\n    }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function(f) {\n    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n    var B = Math.sin(f * this.g) / Math.sin(this.g);\n    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n    var lon = R2D * Math.atan2(y, x);\n    return [lon, lat];\n};\n\n\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function(npoints,options) {\n    var first_pass = [];\n    if (!npoints || npoints <= 2) {\n        first_pass.push([this.start.lon, this.start.lat]);\n        first_pass.push([this.end.lon, this.end.lat]);\n    } else {\n        var delta = 1.0 / (npoints - 1);\n        for (var i = 0; i < npoints; ++i) {\n            var step = delta * i;\n            var pair = this.interpolate(step);\n            first_pass.push(pair);\n        }\n    }\n    /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n    var bHasBigDiff = false;\n    var dfMaxSmallDiffLong = 0;\n    // from http://www.gdal.org/ogr2ogr.html\n    // -datelineoffset:\n    // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n    var dfDateLineOffset = options && options.offset ? options.offset : 10;\n    var dfLeftBorderX = 180 - dfDateLineOffset;\n    var dfRightBorderX = -180 + dfDateLineOffset;\n    var dfDiffSpace = 360 - dfDateLineOffset;\n\n    // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n    for (var j = 1; j < first_pass.length; ++j) {\n        var dfPrevX = first_pass[j-1][0];\n        var dfX = first_pass[j][0];\n        var dfDiffLong = Math.abs(dfX - dfPrevX);\n        if (dfDiffLong > dfDiffSpace &&\n            ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) || (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))) {\n            bHasBigDiff = true;\n        } else if (dfDiffLong > dfMaxSmallDiffLong) {\n            dfMaxSmallDiffLong = dfDiffLong;\n        }\n    }\n\n    var poMulti = [];\n    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n        var poNewLS = [];\n        poMulti.push(poNewLS);\n        for (var k = 0; k < first_pass.length; ++k) {\n            var dfX0 = parseFloat(first_pass[k][0]);\n            if (k > 0 &&  Math.abs(dfX0 - first_pass[k-1][0]) > dfDiffSpace) {\n                var dfX1 = parseFloat(first_pass[k-1][0]);\n                var dfY1 = parseFloat(first_pass[k-1][1]);\n                var dfX2 = parseFloat(first_pass[k][0]);\n                var dfY2 = parseFloat(first_pass[k][1]);\n                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 == 180 &&\n                    k+1 < first_pass.length &&\n                   first_pass[k-1][0] > -180 && first_pass[k-1][0] < dfRightBorderX)\n                {\n                     poNewLS.push([-180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 == -180 &&\n                     k+1 < first_pass.length &&\n                     first_pass[k-1][0] > dfLeftBorderX && first_pass[k-1][0] < 180)\n                {\n                     poNewLS.push([180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                }\n\n                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX)\n                {\n                    // swap dfX1, dfX2\n                    var tmpX = dfX1;\n                    dfX1 = dfX2;\n                    dfX2 = tmpX;\n                    // swap dfY1, dfY2\n                    var tmpY = dfY1;\n                    dfY1 = dfY2;\n                    dfY2 = tmpY;\n                }\n                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n                    dfX2 += 360;\n                }\n\n                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2)\n                {\n                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n                    poNewLS = [];\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n                    poMulti.push(poNewLS);\n                }\n                else\n                {\n                    poNewLS = [];\n                    poMulti.push(poNewLS);\n                }\n                poNewLS.push([dfX0, first_pass[k][1]]);\n            } else {\n                poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n            }\n        }\n    } else {\n        // add normally\n        var poNewLS0 = [];\n        poMulti.push(poNewLS0);\n        for (var l = 0; l < first_pass.length; ++l) {\n            poNewLS0.push([first_pass[l][0],first_pass[l][1]]);\n        }\n    }\n\n    var arc = new Arc(this.properties);\n    for (var m = 0; m < poMulti.length; ++m) {\n        var line = new LineString();\n        arc.geometries.push(line);\n        var points = poMulti[m];\n        for (var j0 = 0; j0 < points.length; ++j0) {\n            line.move_to(points[j0]);\n        }\n    }\n    return arc;\n};\n\nif (typeof window === 'undefined') {\n  // nodejs\n  module.exports.Coord = Coord;\n  module.exports.Arc = Arc;\n  module.exports.GreatCircle = GreatCircle;\n\n} else {\n  // browser\n  var arc = {};\n  arc.Coord = Coord;\n  arc.Arc = Arc;\n  arc.GreatCircle = GreatCircle;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/arc/arc.js","import 'arc';\n/**\n * Transform L.LatLng to {x, y} object\n * @param {L.LatLng} latlng\n * @returns {{x: {number}, y: {number}}}\n * @private\n */\nconst _latLngToXY = latlng => ({\n    x: latlng.lng,\n    y: latlng.lat\n});\n\n/**\n * Create array of L.LatLng objects from line produced by arc.js\n * @param {object} line\n * @param {L.LatLng} from\n * @private\n * @returns {Array}\n */\nfunction _createLatLngs(line, from) {\n    if (line.geometries[0] && line.geometries[0].coords[0]) {\n        /**\n         * stores how many times arc is broken over 180 longitude\n         * @type {number}\n         */\n        let wrap = from.lng - line.geometries[0].coords[0][0] - 360;\n\n        return line.geometries\n            .map(subLine => {\n                wrap += 360;\n                return subLine.coords.map(point => L.latLng([point[1], point[0] + wrap]));\n            })\n            .reduce((all, latlngs) => all.concat(latlngs));\n    } else {\n        return [];\n    }\n}\n\nif (!L) {\n    throw new Error('Leaflet is not defined');\n} else {\n    /**\n     *\n     * @param {L.LatLng} _from\n     * @param {L.LatLng} _to\n     * @param {...object} _options\n     * @param {..number} _options.vertices\n     * @param {..number} _options.offset\n     * @returns {L.Polyline}\n     * @constructor\n     */\n    L.Polyline.Arc = (_from, _to, _options) => {\n\n        const from = L.latLng(_from);\n        const to = L.latLng(_to);\n        const options = {\n            vertices: 10,\n            offset: 10,\n            ..._options\n        };\n\n        const generator = new arc.GreatCircle(_latLngToXY(from), _latLngToXY(to));\n\n        const arcLine = generator.Arc(options.vertices, {offset: options.offset});\n        const latLngs = _createLatLngs(arcLine, from);\n        return L.polyline(latLngs, options);\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/leaflet-arc.js"],"sourceRoot":""}